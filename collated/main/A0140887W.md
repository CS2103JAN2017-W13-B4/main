# A0140887W
###### \java\seedu\doist\logic\commands\FinishCommand.java
``` java
/**
 * Marks the task as 'finished' identified using it's last displayed index from the to-do list.
 */
public class FinishCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "finish";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": Marks the tasks as 'finished' identified by the index numbers used in the last task listing.\n"
            + "Parameters: INDEX [INDEX...] (must be a positive integer)\n"
            + "Example: " + DEFAULT_COMMAND_WORD + " 1 8";

    public static final String MESSAGE_FINISH_TASK_SUCCESS = "Finished Tasks: %1$s";
    public static final String MESSAGE_TASK_ALREADY_FINISHED = "Tasks already finished: %1$s";

    public final int[] targetIndices;

    public FinishCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute() throws CommandException {
        String outputMessage = "";

        ArrayList<ReadOnlyTask> tasksToFinish = getMultipleTasksFromIndices(targetIndices);
        ArrayList<ReadOnlyTask> tasksFinished = new ArrayList<ReadOnlyTask>();
        ArrayList<ReadOnlyTask> tasksAlreadyFinished = new ArrayList<ReadOnlyTask>();

        for (ReadOnlyTask task : tasksToFinish) {
            try {
                model.finishTask(task);
                tasksFinished.add(task);
            } catch (TaskNotFoundException tnfe) {
                assert false : "The target task cannot be missing";
            } catch (TaskAlreadyFinishedException e) {
                tasksAlreadyFinished.add(task);
            }
        }
        if (!tasksAlreadyFinished.isEmpty()) {
            outputMessage += String.format(MESSAGE_TASK_ALREADY_FINISHED, tasksAlreadyFinished + "\n");
        }
        if (!tasksFinished.isEmpty()) {
            outputMessage += String.format(MESSAGE_FINISH_TASK_SUCCESS, tasksFinished);
        }
        return new CommandResult(outputMessage, true);
    }
}
```
###### \java\seedu\doist\logic\commands\ListCommand.java
``` java
    private String processListPreamble(String preamble) {
     // remove all trailing spaces, new line characters etc
        String processedPreamble = preamble.trim();

        // remove all leading spaces, new line characters etc
        processedPreamble = processedPreamble.replaceAll("^\\s+", "");

        // replace in-between spaces, new line characters etc with _
        processedPreamble = processedPreamble.replaceAll("\\s+", "_");

        // change to uppercase
        processedPreamble = processedPreamble.toUpperCase();
        return processedPreamble;
    }

    private void listAll() {
        type = null;
    }

    /** Default list type if there is no preamble */
    private void listDefault() {
        type = TaskType.NOT_FINISHED;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(type, tagList);
        String message = "";
        if (type != null) {
            if (type.equals(TaskType.PENDING)) {
                message = MESSAGE_PENDING;
            } else if (type.equals(TaskType.FINISHED)) {
                message = MESSAGE_FINISHED;
            } else if (type.equals(TaskType.NOT_FINISHED)) {
                message = MESSAGE_NOTFINISHED;
            } else if (type.equals(TaskType.OVERDUE)) {
                message = MESSAGE_OVERDUE;
            } else {
                message = "";
            }
        } else {
            message = MESSAGE_ALL;
        }
        CommandResult commandResult = tagList.isEmpty() ?
                                      new CommandResult(message) :
                                      new CommandResult(getSuccessMessageListUnder(message, tagList));
        return commandResult;
    }

    public static String getSuccessMessageListUnder(String messageSuccess, UniqueTagList tagList) {
        String message = messageSuccess + " under: ";
        for (Tag tag : tagList) {
            message += tag.tagName + " ";
        }
        message = message.trim();
        return message;
    }
}
```
###### \java\seedu\doist\logic\commands\SortCommand.java
``` java
/**
 * Sorts all persons in the to-do list by the specified parameter and shows it to the user.
 */
public class SortCommand extends Command {

    public enum SortType {
        PRIORITY,
        TIME,
        ALPHA
    }

    public List<SortType> sortTypes = new ArrayList<SortType>();

    public static final String DEFAULT_COMMAND_WORD = "sort";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ":\n" + "Sorts previously listed tasks." + "\n"
            + "You can sort by priority, alphabetical order or by time\n\t"
            + "SORT_TYPE can be PRIORITY, TIME, or ALPHA\n"
            + "Parameters: SORT_TYPE " + "\n\t"
            + "Example: " + DEFAULT_COMMAND_WORD
            + "alpha";

    public static final String MESSAGE_SORT_CONSTRAINTS =
            "You can only " + DEFAULT_COMMAND_WORD + "\n"
            + SortType.PRIORITY.toString() + " "
            + SortType.ALPHA.toString() + " "
            + SortType.TIME.toString();

    public SortCommand(List<SortType> list) {
        this.sortTypes = list;
    }

    @Override
    public CommandResult execute() {
        model.sortTasks(sortTypes);
        return new CommandResult(getMessageForPersonListSortedSummary(sortTypes));
    }
}
```
###### \java\seedu\doist\logic\parser\SortCommandParser.java
``` java
public class SortCommandParser {
    public Command parse(String argument) {
        // Remove trailing whitespace
        String processedArgument = argument.trim();
        // remove all leading spaces, new line characters etc
        processedArgument = processedArgument.replaceAll("^\\s+", "");
        // remove extra spaces in between, change to single space
        processedArgument = processedArgument.replaceAll("\\s+", " ");
        processedArgument = processedArgument.toUpperCase();

        String[] arguments = processedArgument.split(" ");

        if (!areValidSortArguments(arguments)) {
            return new IncorrectCommand(String.format(SortCommand.MESSAGE_SORT_CONSTRAINTS, SortCommand.MESSAGE_USAGE));
        }
        return new SortCommand(stringArrayToSortTypeList(arguments));
    }

    /**
     * Returns true if a given string array has a valid sort arguments
     */
    public static boolean areValidSortArguments(String[] arguments) {
        for (String argument : arguments) {
            if (!checkIfValidSortType(argument)) {
                return false;
            }
        }
        return true;
    }

    private static boolean checkIfValidSortType(String argument) {
        return argument.equals(SortType.PRIORITY.toString()) ||
                argument.equals(SortType.ALPHA.toString()) ||
                argument.equals(SortType.TIME.toString());
    }

    private static List<SortType> stringArrayToSortTypeList(String[] arguments) {
        List<SortType> list = new ArrayList<SortType>();
        try {
            for (String argument : arguments) {
                list.add(SortType.valueOf(argument));
            }
        } catch (IllegalArgumentException e) {
            assert false : "Should check that arguments are valid sort type before converting to list";
        }
        return list;
    }
}
```
###### \java\seedu\doist\model\ModelManager.java
``` java
    @Override
    public synchronized void finishTask(ReadOnlyTask target) throws TaskNotFoundException,
        TaskAlreadyFinishedException {
        assert target != null;
        try {
            todoList.changeTaskFinishStatus(target, true);
        } catch (TaskAlreadyUnfinishedException e) {
            assert false : "finishTask should not try to unfinish tasks!";
        }
        indicateTodoListChanged();
    }

    @Override
    public synchronized void unfinishTask(ReadOnlyTask target) throws TaskNotFoundException,
        TaskAlreadyUnfinishedException {
        try {
            todoList.changeTaskFinishStatus(target, false);
        } catch (TaskAlreadyFinishedException e) {
            assert false : "unfinishTask should not try to finish tasks!";
        }
        indicateTodoListChanged();
    }

```
###### \java\seedu\doist\model\ModelManager.java
``` java
    @Override
    public void sortTasks(List<SortType> sortTypes) {
        List<Comparator<ReadOnlyTask>> comparatorList = new ArrayList<Comparator<ReadOnlyTask>>();
        for (SortType type : sortTypes) {
            if (type.equals(SortType.PRIORITY)) {
                comparatorList.add(new ReadOnlyTaskPriorityComparator());
            } else if (type.equals(SortType.TIME)) {
                comparatorList.add(new ReadOnlyTaskTimingComparator());
            } else if (type.equals(SortType.ALPHA)) {
                comparatorList.add(new ReadOnlyTaskAlphabetComparator());
            }
        }
        todoList.sortTasks(new ReadOnlyTaskCombinedComparator(comparatorList));
    }

    public void sortTasksByDefault() {
        List<SortType> sortTypes = new ArrayList<SortType>();
        sortTypes.add(SortType.TIME);
        sortTypes.add(SortType.PRIORITY);
        sortTypes.add(SortType.ALPHA);
        sortTasks(sortTypes);
    }
```
###### \java\seedu\doist\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowDefault() {
        filteredTasks.setPredicate(null);
        Qualifier[] qualifiers = {new TaskTypeQualifier(TaskType.NOT_FINISHED)};
        updateFilteredTaskList(new PredicateExpression(qualifiers));
    }

```
###### \java\seedu\doist\model\task\Priority.java
``` java
/**
 * Represents a task's priority in the to-do list
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 * Default value is NORMAL if not set by user.
 */
public class Priority {

    public static final String EXAMPLE = "HIGH";
    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should be 'NORMAL', "
            + "'IMPORTANT' or 'VERY IMPORTANT'";
    public static final PriorityLevel DEFAULT_PRIORITY = PriorityLevel.NORMAL;

    public enum PriorityLevel {
        NORMAL("Normal"), IMPORTANT("Important"), VERY_IMPORTANT("Very Important");

        private String strValue;
        PriorityLevel(String value) {
            this.strValue = value;
        }

        @Override
        public String toString() {
            return this.strValue;
        }
    }
    private final PriorityLevel priority;

    /**
     * If no parameters are given, it is set to default priority
     */
    public Priority() {
        this.priority = DEFAULT_PRIORITY;
    }

    /**
     * Validates given string priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        final String processedPriority = processPriorityString(priority);
        if (!isValidPriority(processedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
        this.priority = PriorityLevel.valueOf(processedPriority);
    }

    public PriorityLevel getPriorityLevel() {
        return priority;
    }

    /**
     * Returns true if a given string is a valid priority
     */
    public static boolean isValidPriority(String priority) {
        return priority.equals(PriorityLevel.VERY_IMPORTANT.name())
                || priority.equals(PriorityLevel.IMPORTANT.name())
                || priority.equals(PriorityLevel.NORMAL.name());
    }

    /**
     * Process string to process all whitespace, spaces and new line and
     * change all characters to upper case so that it will be a
     * valid priority string
     * @returns string of the processed priority string
     */
    public static String processPriorityString(String priority) {
        // remove all trailing spaces, new line characters etc
        String processedPriority = priority.trim();

        // remove all leading spaces, new line characters etc
        processedPriority = processedPriority.replaceAll("^\\s+", "");

        // replace in-between spaces, new line characters etc with _
        processedPriority = processedPriority.replaceAll("\\s+", "_");
        processedPriority = processedPriority.toUpperCase();
        return processedPriority;
    }

    @Override
    public String toString() {
        return priority.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                && this.priority.equals((((Priority) other).priority))); // state check
    }

    @Override
    public int hashCode() {
        return priority.toString().hashCode();
    }

}
```
###### \java\seedu\doist\model\task\ReadOnlyTask.java
``` java
    /**
     * Compare the priority of two tasks
     * @return: -1 if task2 has a lower priority than task1
     */
    public class ReadOnlyTaskPriorityComparator implements Comparator<ReadOnlyTask> {
        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            // Highest priority to lowest priority
            PriorityLevel task1Priority = task1.getPriority().getPriorityLevel();
            PriorityLevel task2Priority = task2.getPriority().getPriorityLevel();
            return task2Priority.compareTo(task1Priority);
        }
    }

    /**
     * Compare the timing of two tasks
     * @return: -1 if task1 is earlier than task2
     */
    public class ReadOnlyTaskTimingComparator implements Comparator<ReadOnlyTask> {
        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            // Earliest to latest timing
            Date date1 = task1.getDates().getStartDate();
            Date date2 = task2.getDates().getStartDate();
            // Floating tasks are put behind
            if (date1 == null) {
                return 1;
            } else if (date2 == null) {
                return -1;
            }
            return date1.compareTo(date2);
        }
    }

    /**
     * Compare the tasks by alphabetical order of their description
     * @return: -1 if task1 is less than task2 (alphabetical order)
     */
    public class ReadOnlyTaskAlphabetComparator implements Comparator<ReadOnlyTask> {
        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            // A to Z
            String desc1 = task1.getDescription().desc;
            String desc2 = task2.getDescription().desc;
            return desc1.compareTo(desc2);
        }
    }

    /**
     * Combines multiple comparators together to compare tasks.
     * For example if you want to sort by end time then by priority,
     * you create a list of comparators, adding the end time comparator first
     * then adding the priority comparator.
     * @return: -1 task1 is compared to be "less" than task2 based on multiple comparators
     */
    public class ReadOnlyTaskCombinedComparator implements Comparator<ReadOnlyTask> {

        private List<Comparator<ReadOnlyTask>> comparators;

        public ReadOnlyTaskCombinedComparator(List<Comparator<ReadOnlyTask>> comparators) {
            this.comparators = comparators;
        }

        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            int compareResult = 0;
            for (Comparator<ReadOnlyTask> comparator : comparators) {
                if (comparator.compare(task1, task2) != 0) {
                    return comparator.compare(task1, task2);
                }
            }
            return compareResult;
        }
    }
}
```
###### \java\seedu\doist\model\task\UniqueTaskList.java
``` java
    /**
     * Sorts the internal list with comparator
     */
    public void sort(Comparator<ReadOnlyTask> comparator) {
        assert comparator != null;
        internalList.sort(comparator);
    }

```
###### \java\seedu\doist\model\task\UniqueTaskList.java
``` java
    /**
     * Changes the finish status of the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws TaskAlreadyFinishedException if task is already finished but trying to finish it
     * @throws TaskAlreadyUnfinishedException if task is already not finished but trying to unfinish it
     * @returns true if finish status of task is successfully changed
     */
    public boolean changeFinishStatus(ReadOnlyTask toChangeFinish, boolean isToFinish) throws TaskNotFoundException,
            TaskAlreadyFinishedException, TaskAlreadyUnfinishedException {
        assert toChangeFinish != null;

        // Find task in internal list
        final int taskIndex = internalList.indexOf(toChangeFinish);
        boolean taskExists = taskIndex < 0 ? false : true;

        if (!taskExists) {
            throw new TaskNotFoundException();
        } else {
            Task taskToUpdate = internalList.get(taskIndex);
            if (isToFinish) {
                finishTask(taskToUpdate);
            } else {
                unfinishTask(taskToUpdate);
            }
            // Update the observable list so that UI can be updated too
            internalList.set(taskIndex, taskToUpdate);
        }
        return taskExists;
    }

    private void finishTask(Task toFinish) throws TaskAlreadyFinishedException {
        if (toFinish.getFinishedStatus().getIsFinished()) {
            logger.info("Attemping to finish task already finished, task details:\n" + toFinish.getAsText());
            throw new TaskAlreadyFinishedException();
        } else {
            toFinish.setFinishedStatus(new FinishedStatus(true));
        }
    }

    private void unfinishTask(Task toUnfinish) throws TaskAlreadyUnfinishedException {
        if (!toUnfinish.getFinishedStatus().getIsFinished()) {
            logger.info("Attemping to unfinish task that is already not finished, task details:\n"
                    + toUnfinish.getAsText());
            throw new TaskAlreadyUnfinishedException();
        } else {
            toUnfinish.setFinishedStatus(new FinishedStatus(false));
        }
    }

```
###### \java\seedu\doist\model\task\UniqueTaskList.java
``` java
    /**
     * Signals that a task is already finished and you are trying to finish it again
     */
    public static class TaskAlreadyFinishedException extends Exception {}

    /**
     * Signals that a task is already not finished and you are trying to unfinish it
     */
    public static class TaskAlreadyUnfinishedException extends Exception {}

}
```
###### \java\seedu\doist\model\TodoList.java
``` java
    public boolean changeTaskFinishStatus(ReadOnlyTask readOnlyTaskToFinish, boolean isToFinish)
            throws TaskNotFoundException, TaskAlreadyFinishedException, TaskAlreadyUnfinishedException {
        assert readOnlyTaskToFinish != null;

        Task taskToFinish = new Task(readOnlyTaskToFinish);
        return tasks.changeFinishStatus(taskToFinish, isToFinish);
    }

```
###### \java\seedu\doist\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    private static final String NULL_STRING = "null";

    @XmlElement(required = true)
    private String desc;

    @XmlElement(required = true)
    private String priority;

    @XmlElement(required = true)
    private String finishedStatus;

    @XmlElement(required = true)
    private String startDate;

    @XmlElement(required = true)
    private String endDate;

    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        desc = source.getDescription().desc;
        priority = source.getPriority().getPriorityLevel().toString();
        finishedStatus = Boolean.toString(source.getFinishedStatus().getIsFinished());
        startDate = getDateString(source.getDates().getStartDate());
        endDate = getDateString(source.getDates().getEndDate());
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    private String getDateString(Date date) {
        if (date != null) {
            return date.toString();
        } else {
            return NULL_STRING;
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        // instead of throwing illegal value exception,
        // can consider just removing the invalid data
        final List<Tag> personTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            personTags.add(tag.toModelType());
        }
        final Description name = new Description(this.desc);
        final Priority priority = new Priority(this.priority);
        final FinishedStatus finishedStatus = new FinishedStatus(Boolean.parseBoolean(this.finishedStatus));
        final Date startDate = getDate(this.startDate);
        final Date endDate = getDate(this.endDate);
        final UniqueTagList tags = new UniqueTagList(personTags);

        return new Task(name, priority, finishedStatus, new TaskDate(startDate, endDate), tags);
    }

    private Date getDate(String dateString) {
        if (dateString.equals(NULL_STRING)) {
            return null;
        } else {
            return TaskDate.parseDate(dateString);
        }
    }
}
```
###### \java\seedu\doist\ui\CommandBox.java
``` java
    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
        // Only add success style if don't already have
        if (!commandTextField.getStyleClass().contains(SUCCESS_STYLE_CLASS)) {
            commandTextField.getStyleClass().add(SUCCESS_STYLE_CLASS);
        }
    }

    /**
     * Sets the command box style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        commandTextField.getStyleClass().remove(SUCCESS_STYLE_CLASS);
        // Only add error style if don't already have
        if (!commandTextField.getStyleClass().contains(ERROR_STYLE_CLASS)) {
            commandTextField.getStyleClass().add(ERROR_STYLE_CLASS);
        }
    }
}
```
###### \java\seedu\doist\ui\MainWindow.java
``` java
    @FXML
    private void handleDarkTheme() {
        changeToTheme(darkThemeUrl);
    }

    @FXML
    private void handleLightTheme() {
        changeToTheme(lightThemeUrl);
    }

    private void changeToTheme(String themeUrl) {
        Scene scene = primaryStage.getScene();
        // Remove all existing stylesheets
        scene.getStylesheets().removeAll(themeUrls);
        // Add the new stylesheet
        if (!scene.getStylesheets().contains(themeUrl)) {
            scene.getStylesheets().add(themeUrl);
        }
    }

```
###### \java\seedu\doist\ui\TaskCard.java
``` java
    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        setStyleToNormal();
        desc.setText(task.getDescription().desc);
        id.setText(displayedIndex + ". ");
        priority.setText(task.getPriority().toString());

        // Times
        if (task.getDates().isDeadline()) {
            startTime.setText(BY_TIME_TEXT + task.getDates().getStartDate());
            endTime.setText("");
        } else if (task.getDates().isEvent()) {
            startTime.setText(START_TIME_TEXT + task.getDates().getStartDate().toString());
            endTime.setText(END_TIME_TEXT + task.getDates().getEndDate().toString());
        } else {
            // floating task
            startTime.setText("");
            endTime.setText("");
        }
        if (task.getDates().isPast()) {
            setStyleToOverdue();
        }

        // Finished
        checkbox.setDisable(true);
        checkbox.setStyle("-fx-opacity: 1");
        if (task.getFinishedStatus().getIsFinished()) {
            checkbox.setSelected(true);
            setStyleToFinished();
        } else {
            checkbox.setSelected(false);
        }

        // Tags
        initTags(task);
    }

    private void initTags(ReadOnlyTask task) {
        task.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }

    /**
     * Sets the card pane style to the style of a normal task
     */
    private void setStyleToNormal() {
        cardPane.getStyleClass().remove(OVERDUE_STYLE_CLASS);
        cardPane.getStyleClass().remove(FINISHED_STYLE_CLASS);
        // Only add style if don't already have
        if (!cardPane.getStyleClass().contains(NORMAL_STYLE_CLASS)) {
            cardPane.getStyleClass().add(NORMAL_STYLE_CLASS);
        }
    }

    /**
     * Sets the card pane style to the style of an overdue task
     */
    private void setStyleToOverdue() {
        cardPane.getStyleClass().remove(NORMAL_STYLE_CLASS);
        cardPane.getStyleClass().remove(FINISHED_STYLE_CLASS);
        // Only add style if don't already have
        if (!cardPane.getStyleClass().contains(OVERDUE_STYLE_CLASS)) {
            cardPane.getStyleClass().add(OVERDUE_STYLE_CLASS);
        }
    }

    /**
     * Sets the card pane style to the style of a normal task
     */
    private void setStyleToFinished() {
        cardPane.getStyleClass().remove(OVERDUE_STYLE_CLASS);
        cardPane.getStyleClass().remove(NORMAL_STYLE_CLASS);
        // Only add style if don't already have
        if (!cardPane.getStyleClass().contains(FINISHED_STYLE_CLASS)) {
            cardPane.getStyleClass().add(FINISHED_STYLE_CLASS);
        }
    }
}
```
###### \resources\view\DarkTheme.css
``` css
@import url("CommandBoxCss.css");
@import url("Extensions.css");

.background {
    -fx-background-color: #000000;
}

.check-box>.box {
  -fx-background-insets: 0;
  -fx-background-radius: 0;
  -fx-background-color: #777777;
}

.check-box > .box > .mark {
    -fx-background-color: white;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.list-view {
    -fx-selection-bar:#777777;
    -fx-selection-bar-non-focused: #777777;
    -fx-background-insets: 0;
    -fx-padding: -2px;
}

.list-view .list-cell:even {
    -fx-control-inner-background: #424242;
}

.list-view .list-cell:odd {
    -fx-control-inner-background: #303030;
}

.list-cell {
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
    -fx-border-color: transparent;
}

.list-cell .label {
    -fx-text-fill: white;
}

.cell_big_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_small_label {
    -fx-font-size: 11px;
    -fx-text-fill: #010504;
}

.anchor-pane {
     -fx-background-color:#303030;
     -fx-text-fill: #010504;
}

.anchor-pane-with-border {
     -fx-background-color: #303030;
     -fx-border-color: #303030;
     -fx-border-top-width: 1px;
}

.status-bar {
    -fx-background-color: #000000;
}

.result-display {
    -fx-background-color: #000000;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: white;
}

.status-bar-with-border {
    -fx-background-color: #303030;
    -fx-border-color: transparent;
    -fx-border-width: 0px;
}

.status-bar-with-border .label {
    -fx-text-fill: white;
}

.grid-pane {
    -fx-background-color: transparent;
    -fx-border-color: #303030;
    -fx-border-width: 1px;
}

.grid-pane .anchor-pane {
    -fx-background-color: #303030;
}

.context-menu {
    -fx-background-color: #303030;
}

.context-menu .label {
    -fx-text-fill: white;
}

.menu-bar {
    -fx-background-color:#303030;
}

.menu-item:focused {
    -fx-background-color:#212121;
}
.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: black;
}

.menu:showing {
    -fx-background-color: #303030;
}
.menu:hover {
    -fx-background-color: #303030;
}
/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: derive(#1d1d1d, 25%);
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-font-style: italic;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .track-background {
    -fx-background-color: #212121;
}
.scroll-bar .thumb {
    -fx-background-color: #555555;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-width: 0 0 0 4;
}

/* for normal tasks in cardPane */
.normal {
    -fx-border-color: #76d7ea;
}

/* for overdue tasks in cardPane */
.overdue {
    -fx-border-color: #fc80a5;
}

/* for finished tasks in cardPane */
.finished {
    -fx-border-color: #99ff99;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#sideBox {
    -fx-border-color: transparent;
}

.text-area {
    -fx-background-insets: 0;
    -fx-text-fill: white;
    -fx-padding: -2px;
}

.text-area .content {
    -fx-background-color: #212121;
    -fx-border-color: #212121;
}

.text-area:focused .content {
    -fx-background-color: #212121;
}

.text-area:focused {
    -fx-highlight-fill: white;
}

#taskBox {
    -fx-border-color: #212121;
    -fx-border-width: 0 0 0 0;
}

#filterField, #personListPanel, #personWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

#tags {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #888888;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}
```
###### \resources\view\Extensions.css
``` css
.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}

.tooltip-text {
    -fx-text-fill: white;
}

.error {
    -fx-background-color: #ffb3b3;
}

.white {
    -fx-background-color: #a9a9a9 , white , white;
}
```
###### \resources\view\LightTheme.css
``` css
@import url("CommandBoxCss.css");
@import url("Extensions.css");

.background {
    -fx-background-color: #000000;
}

.check-box>.box {
  -fx-background-insets: 0;
  -fx-background-radius: 0;
  -fx-background-color: #DFEFF0;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.list-view {
    -fx-selection-bar:#A0C6DD;
    -fx-selection-bar-non-focused: #A0C6DD;
    -fx-background-insets: 0;
}

.list-view .list-cell:even {
    -fx-control-inner-background: #F5FAFA;
    -fx-text-fill: black;
}

.list-view .list-cell:odd {
    -fx-control-inner-background: transparent;
    -fx-text-fill: black;
}

.list-cell {
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
    -fx-border-color: transparent;
}

.list-cell .label {
    -fx-text-fill: #010504;
}

.cell_big_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_small_label {
    -fx-font-size: 11px;
    -fx-text-fill: #010504;
}

.anchor-pane {
     -fx-background-color:#FFFFFF;
     -fx-text-fill: #010504;
}

.anchor-pane-with-border {
     -fx-background-color: #FFFFFF;
     -fx-border-color: #FFFFFF;
     -fx-border-top-width: 1px;
}

.status-bar {
    -fx-background-color: #000000;
}

.result-display {
    -fx-background-color: #000000;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: black;
}

.status-bar-with-border {
    -fx-background-color: #FFFFFF;
    -fx-border-color: transparent;
    -fx-border-width: 0px;
}

.status-bar-with-border .label {
    -fx-text-fill: black;
}

.grid-pane {
    -fx-background-color: transparent;
    -fx-border-color: transparent;
    -fx-border-width: 1px;
}

.grid-pane .anchor-pane {
    -fx-background-color: #FFFFFF;
}

.context-menu {
    -fx-background-color: #FFFFFF;
}

.context-menu .label {
    -fx-text-fill: black;
}

.menu-bar {
    -fx-background-color:#FFFFFF;
}

.menu-item:focused {
    -fx-background-color:#F5FAFA;
}
.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: black;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: black;
}

.menu:showing {
    -fx-background-color: #F5FAFA;
}
.menu:hover {
    -fx-background-color: #F5FAFA;
}
/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: derive(#1d1d1d, 25%);
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-font-style: italic;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .track-background {
    -fx-background-color: #F5FAFA;
}
.scroll-bar .thumb {
    -fx-background-color: #6D929B;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-width: 0 0 0 4;
}

/* for normal tasks in cardPane */
.normal {
    -fx-border-color: #76d7ea;
}

/* for overdue tasks in cardPane */
.overdue {
    -fx-border-color: #fc80a5;
}

/* for finished tasks in cardPane */
.finished {
    -fx-border-color: #99ff99;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#sideBox {
    -fx-border-color: transparent;
}

.text-area {
    -fx-background-insets: 0;
    -fx-background-color: #F5FAFA;
    -fx-text-fill: #005B9A;
}

.text-area .content {
    -fx-background-color: #F5FAFA;
}

.text-area:focused .content {
    -fx-background-color: #F5FAFA;
}

.text-area:focused {
    -fx-highlight-fill: #7ecfff;
}

#taskBox {
    -fx-border-color: #89CFF0;
    -fx-border-width: 0 0 0 0;
}

#filterField, #personListPanel, #personWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

#tags {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #383838;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}
```
###### \resources\view\MainWindow.fxml
``` fxml

<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Theme">
              <items>
                <MenuItem mnemonicParsing="false" onAction="#handleLightTheme" text="LightTheme" />
                  <MenuItem mnemonicParsing="false" onAction="#handleDarkTheme" text="DarkTheme" />
              </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
       <AnchorPane styleClass="anchor-pane" VBox.vgrow="ALWAYS">
          <children>
               <VBox fx:id="personList" maxHeight="Infinity" maxWidth="Infinity" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                   <padding>
                       <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                   </padding>
                  <children>
                     <AnchorPane fx:id="personListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                  </children>
               </VBox>
          </children>
       </AnchorPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### \resources\view\TaskListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane fx:id="grid" HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="ALWAYS" maxWidth="40.0" />
            <ColumnConstraints hgrow="ALWAYS" minWidth="150.0" prefWidth="100.0" />
            </columnConstraints>
            <children>
            <VBox fx:id="sideBox" maxWidth="100.0" prefHeight="100.0" prefWidth="10.0">
               <children>
                  <CheckBox fx:id="checkbox" mnemonicParsing="false">
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </CheckBox>
               </children>
            </VBox>
            <VBox fx:id="taskBox" prefHeight="100.0" GridPane.columnIndex="1">
               <children>
                          <HBox>
                            <children>
                             <Label fx:id="id" styleClass="cell_big_label"></Label>
                                 <Label fx:id="desc" styleClass="cell_big_label" text="\$first" />
                             </children>
                          </HBox>
                        <FlowPane fx:id="tags" alignment="CENTER_LEFT" />
                        <Label fx:id="priority" styleClass="cell_small_label" text="\$priority" />
                        <Label fx:id="startTime" styleClass="cell_small_label" text="\$startTime" />
                        <Label fx:id="endTime" styleClass="cell_small_label" text="\$endTime" />
               </children>
            </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
