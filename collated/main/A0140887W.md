# A0140887W
###### \java\seedu\doist\commons\core\Config.java
``` java
/**
 * Config values used by the app
 */
public class Config {

    public static final String DEFAULT_CONFIG_FILE = "config.json";
    public static String lastUsedFile = "";

    // Config values customizable through config file
    private String appTitle = "Doist";
    private Level logLevel = Level.INFO;
    private String absoluteStoragePath = "";
    private String userPrefsFilePath = "preferences.json";
    private String todoListFilePath = "data" + File.separator + "todolist.xml";
    private String aliasListMapFilePath = "data" + File.separator + "aliaslistmap.xml";
    private String todoListName = "MyTodoList";

    public Config() {
        // Gets current working directory of Doist (in operating system platform-specific style)
        absoluteStoragePath = Paths.get(".").toAbsolutePath().normalize().toString();
    }

    public String getAppTitle() {
        return appTitle;
    }

    public void setAppTitle(String appTitle) {
        this.appTitle = appTitle;
    }

    public Level getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(Level logLevel) {
        this.logLevel = logLevel;
    }

    public String getAbsoluteStoragePath() {
        return absoluteStoragePath;
    }

    /** Model should call this to save the absolute storage path */
    public void setAbsoluteStoragePath(String absoluteStoragePath) {
        this.absoluteStoragePath = absoluteStoragePath;
    }

    public String getUserPrefsFilePath() {
        return userPrefsFilePath;
    }

    public String getAbsoluteUserPrefsFilePath() {
        return absoluteStoragePath + File.separator + userPrefsFilePath;
    }

    public void setUserPrefsFilePath(String userPrefsFilePath) {
        this.userPrefsFilePath = userPrefsFilePath;
    }

    public String getTodoListFilePath() {
        return todoListFilePath;
    }

    public String getAbsoluteTodoListFilePath() {
        return absoluteStoragePath + File.separator + todoListFilePath;
    }

    public void setTodoListFilePath(String todoListFilePath) {
        this.todoListFilePath = todoListFilePath;
    }

    public String getAliasListMapFilePath() {
        return aliasListMapFilePath;
    }

    public String getAbsoluteAliasListMapFilePath() {
        return absoluteStoragePath + File.separator + aliasListMapFilePath;
    }

    public void setAliasListMapFilePath(String aliasListMapFilePath) {
        this.aliasListMapFilePath = aliasListMapFilePath;
    }

    public String getTodoListName() {
        return todoListName;
    }

    public void setTodoListName(String todoListName) {
        this.todoListName = todoListName;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }
        if (!(other instanceof Config)) { //this handles null as well.
            return false;
        }

        Config o = (Config) other;

        return Objects.equals(appTitle, o.appTitle)
                && Objects.equals(logLevel, o.logLevel)
                && Objects.equals(absoluteStoragePath, o.absoluteStoragePath)
                && Objects.equals(userPrefsFilePath, o.userPrefsFilePath)
                && Objects.equals(aliasListMapFilePath, o.aliasListMapFilePath)
                && Objects.equals(todoListFilePath, o.todoListFilePath)
                && Objects.equals(todoListName, o.todoListName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(appTitle, logLevel, absoluteStoragePath, userPrefsFilePath,
                aliasListMapFilePath, todoListFilePath, todoListName);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("App title : " + appTitle);
        sb.append("\nCurrent log level : " + logLevel);
        sb.append("\nAbsolute Storage Path : " + absoluteStoragePath);
        sb.append("\nPreference file Location : " + userPrefsFilePath);
        sb.append("\nAlias List Map file location : " + aliasListMapFilePath);
        sb.append("\nLocal data file location : " + todoListFilePath);
        sb.append("\nTodoList name : " + todoListName);
        return sb.toString();
    }

}
```
###### \java\seedu\doist\commons\events\config\AbsoluteStoragePathChangedEvent.java
``` java
/** Indicates the absolute storage path in config has changed*/
public class AbsoluteStoragePathChangedEvent extends BaseEvent {

    public final String todoListPath;
    public final String aliasListMapPath;
    public final String userPrefsPath;

    public AbsoluteStoragePathChangedEvent(String todoListPath, String aliasListMapPath, String userPrefsPath) {
        this.todoListPath = todoListPath;
        this.aliasListMapPath = aliasListMapPath;
        this.userPrefsPath = userPrefsPath;
    }

    @Override
    public String toString() {
        return "Paths Changed: " + todoListPath + ", " + aliasListMapPath + ", " + userPrefsPath;
    }
}
```
###### \java\seedu\doist\commons\events\model\AliasListMapChangedEvent.java
``` java
/** Indicates the AliasListMap in the model has changed*/
public class AliasListMapChangedEvent extends BaseEvent {

    public final ReadOnlyAliasListMap data;

    public AliasListMapChangedEvent(ReadOnlyAliasListMap data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return data.toString();
    }
}
```
###### \java\seedu\doist\commons\util\ConfigUtil.java
``` java
    public static String getConfigPath() throws IOException {
        if (!Config.lastUsedFile.isEmpty()) {
            return Config.lastUsedFile;
        } else {
            return Config.DEFAULT_CONFIG_FILE;
        }
    }

}
```
###### \java\seedu\doist\commons\util\FileUtil.java
``` java
    /**
     * Writes given string to a file.
     * Will create the file if it does not exist yet.
     */
    public static void writeToFile(File file, String content) throws IOException {
        // Make sure that dirs is made first before writing
        File newFile = new File(file.getAbsolutePath());
        newFile.getParentFile().mkdirs();
        // Write the file now
        Files.write(file.toPath(), content.getBytes(CHARSET));
    }
```
###### \java\seedu\doist\logic\commands\Command.java
``` java
    /**
     * Constructs a feedback message to summarise an operation that sorted a listing of tasks.
     *
     * @param sortType used in the command
     * @return summary message for tasks sorted
     */
    public static String getMessageForTaskListSortedSummary(List<SortType> sortTypes) {
        return String.format(Messages.MESSAGE_TASKS_SORTED_OVERVIEW, sortTypes.toString());
    }

```
###### \java\seedu\doist\logic\commands\FinishCommand.java
``` java
/**
 * Marks the task as 'finished' identified using it's last displayed index from the to-do list.
 */
public class FinishCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "finish";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": Marks the tasks as 'finished' identified by the index numbers used in the last task listing.\n"
            + "Parameters: INDEX [INDEX...] (must be a positive integer)\n"
            + "Example: " + DEFAULT_COMMAND_WORD + " 1 8";

    public static final String MESSAGE_FINISH_TASK_SUCCESS = "Finished Tasks: %1$s";
    public static final String MESSAGE_TASK_ALREADY_FINISHED = "Tasks already finished: %1$s";

    public final int[] targetIndices;

    public FinishCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        String outputMessage = "";

        ArrayList<ReadOnlyTask> tasksToFinish = getMultipleTasksFromIndices(targetIndices);
        ArrayList<ReadOnlyTask> tasksFinished = new ArrayList<ReadOnlyTask>();
        ArrayList<ReadOnlyTask> tasksAlreadyFinished = new ArrayList<ReadOnlyTask>();

        for (ReadOnlyTask task : tasksToFinish) {
            try {
                int index  = model.finishTask(task);
                if (index >= 0) {
                    EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
                }
                tasksFinished.add(task);
            } catch (TaskNotFoundException tnfe) {
                assert false : "The target task cannot be missing";
            } catch (TaskAlreadyFinishedException e) {
                tasksAlreadyFinished.add(task);
            }
        }
        if (!tasksAlreadyFinished.isEmpty()) {
            outputMessage += String.format(MESSAGE_TASK_ALREADY_FINISHED, tasksAlreadyFinished + "\n");
        }
        if (!tasksFinished.isEmpty()) {
            outputMessage += String.format(MESSAGE_FINISH_TASK_SUCCESS, tasksFinished);
        }
        return new CommandResult(outputMessage, true);
    }
}
```
###### \java\seedu\doist\logic\commands\ListCommand.java
``` java
    public static final String DEFAULT_COMMAND_WORD = "list";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": List tasks as specified by the parameters\n"
            + "TYPE could be pending, overdue or finished. If no TYPE is specified, all tasks will be listed.\n"
            + "Parameters: [TYPE] [\\from START_TIME] [\\to END_TIME] [\\as PRIORITY] [\\under TAG...]\n"
            + "Example: " + DEFAULT_COMMAND_WORD + " pending \\under school ";
    //public static final String MESSAGE_INVALID_PREAMBLE = "Invalid list type! Type should be pending,"
    //                                                        + " overdue or finished";
    public static final String MESSAGE_SUCCESS = "Listed %1$s tasks";
    public static final String MESSAGE_PENDING = String.format(MESSAGE_SUCCESS, "pending");
    public static final String MESSAGE_FINISHED = String.format(MESSAGE_SUCCESS, "finished");
    public static final String MESSAGE_OVERDUE = String.format(MESSAGE_SUCCESS, "overdue");
    public static final String MESSAGE_ALL = String.format(MESSAGE_SUCCESS, "all");

```
###### \java\seedu\doist\logic\commands\ListCommand.java
``` java
    private String processListPreamble(String preamble) {
     // remove all trailing spaces, new line characters etc
        String processedPreamble = preamble.trim();

        // remove all leading spaces, new line characters etc
        processedPreamble = processedPreamble.replaceAll("^\\s+", "");

        // replace in-between spaces, new line characters etc with _
        processedPreamble = processedPreamble.replaceAll("\\s+", "_");

        // change to uppercase
        processedPreamble = processedPreamble.toUpperCase();
        return processedPreamble;
    }

    /** Default list type if there is no preamble */
    private void listDefault() {
        type = TaskType.ALL;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        model.updateFilteredTaskList(type, tagList, dates);
        model.sortTasksByDefault();
        String message = "";
        if (type != null) {
            if (type.equals(TaskType.PENDING)) {
                message = MESSAGE_PENDING;
            } else if (type.equals(TaskType.FINISHED)) {
                message = MESSAGE_FINISHED;
            } else if (type.equals(TaskType.ALL)) {
                message = MESSAGE_ALL;
            } else if (type.equals(TaskType.OVERDUE)) {
                message = MESSAGE_OVERDUE;
            } else {
                message = "";
            }
        } else {
            assert false : "type should not be null!";
        }
        CommandResult commandResult = tagList.isEmpty() ?
                                      new CommandResult(message) :
                                      new CommandResult(getSuccessMessageListUnder(message, tagList));
        return commandResult;
    }

    public static String getSuccessMessageListUnder(String messageSuccess, UniqueTagList tagList) {
        String message = messageSuccess + " under: ";
        for (Tag tag : tagList) {
            message += tag.tagName + " ";
        }
        message = message.trim();
        return message;
    }
}
```
###### \java\seedu\doist\logic\commands\SaveAtCommand.java
``` java
/**
 * Changes the absolute storage path by changing config
 */
public class SaveAtCommand extends Command {

    public File file;

    public static final String DEFAULT_COMMAND_WORD = "save_at";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ":\n" + "Changes the storage folder of Doist." + "\n"
            + "You can use both absolute and relative file paths to a folder. Use // to seperate directories.\n\t"
            + "Parameters: path " + "\n\t"
            + "Example: " + DEFAULT_COMMAND_WORD
            + " C:/Users";

    public static final String MESSAGE_SUCCESS = "New Storage Path is: %1$s";
    public static final String MESSAGE_FILE_EXISTS = "A file already exists with the same name."
            + " Do give a path to a folder!";
    public static final String MESSAGE_INVALID_PATH = "Invalid folder path entered! \n%1$s";


    // TODO: can we undo save as config change too?
    public SaveAtCommand(File file) {
        this.file = file;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        if (file.exists() && !file.isDirectory()) {
            throw new CommandException(MESSAGE_FILE_EXISTS);
        }
        // This would trigger an event that will change storage
        model.changeConfigAbsolutePath(file.toPath().toAbsolutePath());
        return new CommandResult(String.format(MESSAGE_SUCCESS, file));
    }
}
```
###### \java\seedu\doist\logic\commands\SortCommand.java
``` java
/**
 * Sorts all persons in the to-do list by the specified parameter and shows it to the user.
 */
public class SortCommand extends Command {

    public enum SortType {
        PRIORITY,
        TIME,
        ALPHA
    }

    public List<SortType> sortTypes = new ArrayList<SortType>();

    public static final String DEFAULT_COMMAND_WORD = "sort";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ":\n" + "Sorts previously listed tasks." + "\n"
            + "You can sort by priority, alphabetical order or by time\n\t"
            + "SORT_TYPE can be PRIORITY, TIME, or ALPHA\n"
            + "Parameters: SORT_TYPE " + "\n\t"
            + "Example: " + DEFAULT_COMMAND_WORD
            + "alpha";

    public static final String MESSAGE_SORT_CONSTRAINTS =
            "You can only " + DEFAULT_COMMAND_WORD + "\n"
            + SortType.PRIORITY.toString() + " "
            + SortType.ALPHA.toString() + " "
            + SortType.TIME.toString();

    public SortCommand(List<SortType> list) {
        this.sortTypes = list;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        model.sortTasks(sortTypes);
        return new CommandResult(getMessageForTaskListSortedSummary(sortTypes));
    }
}
```
###### \java\seedu\doist\logic\commands\UnfinishCommand.java
``` java
/**
 * Marks the task as 'unfinished' identified using it's last displayed index from the to-do list.
 */
public class UnfinishCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "unfinish";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": Marks the tasks as not 'finished' identified by the index numbers used in the last task listing.\n"
            + "Parameters: INDEX [INDEX...] (must be a positive integer)\n"
            + "Example: " + DEFAULT_COMMAND_WORD + " 1 8";

    public static final String MESSAGE_UNFINISH_TASK_SUCCESS = "Unfinished Tasks: %1$s";
    public static final String MESSAGE_TASK_ALREADY_NOT_FINISHED = "Tasks already not finished: %1$s";

    public final int[] targetIndices;

    public UnfinishCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        String outputMessage = "";

        ArrayList<ReadOnlyTask> tasksToUnfinish = getMultipleTasksFromIndices(targetIndices);
        ArrayList<ReadOnlyTask> tasksUnfinished = new ArrayList<ReadOnlyTask>();
        ArrayList<ReadOnlyTask> tasksAlreadyNotFinished = new ArrayList<ReadOnlyTask>();

        for (ReadOnlyTask task : tasksToUnfinish) {
            try {
                int index  = model.unfinishTask(task);
                if (index >= 0) {
                    System.out.println(index);
                    EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
                }
                tasksUnfinished.add(task);
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            } catch (TaskAlreadyUnfinishedException e) {
                tasksAlreadyNotFinished.add(task);
            }
        }
        if (!tasksAlreadyNotFinished.isEmpty()) {
            outputMessage += String.format(MESSAGE_TASK_ALREADY_NOT_FINISHED, tasksAlreadyNotFinished + "\n");
        }
        if (!tasksUnfinished.isEmpty()) {
            outputMessage += String.format(MESSAGE_UNFINISH_TASK_SUCCESS, tasksUnfinished);
        }
        return new CommandResult(outputMessage, true);
    }
}
```
###### \java\seedu\doist\logic\parser\SaveAtCommandParser.java
``` java
/**
 * Parses input arguments and creates a new SaveAtCommand object
 */
public class SaveAtCommandParser {
    public Command parse(String argument) {
        // Remove trailing whitespace
        String processedArgument = argument.trim();
        // remove all leading spaces, new line characters etc
        processedArgument = processedArgument.replaceAll("^\\s+", "");
        // cannot be empty path
        if (processedArgument.isEmpty()) {
            return new IncorrectCommand(String.format(SaveAtCommand.MESSAGE_INVALID_PATH, SaveAtCommand.MESSAGE_USAGE));
        }
        File file = new File(processedArgument);
        try {
            String path = file.getCanonicalPath();
            return new SaveAtCommand(new File(path));
        } catch (IOException e) {
            return new IncorrectCommand(String.format(SaveAtCommand.MESSAGE_INVALID_PATH, SaveAtCommand.MESSAGE_USAGE));
        } catch (SecurityException e) {
            return new IncorrectCommand(String.format(SaveAtCommand.MESSAGE_INVALID_PATH, SaveAtCommand.MESSAGE_USAGE));
        }
    }
}
```
###### \java\seedu\doist\logic\parser\SortCommandParser.java
``` java
public class SortCommandParser {
    public Command parse(String argument) {
        // Remove trailing whitespace
        String processedArgument = argument.trim();
        // remove all leading spaces, new line characters etc
        processedArgument = processedArgument.replaceAll("^\\s+", "");
        // remove extra spaces in between, change to single space
        processedArgument = processedArgument.replaceAll("\\s+", " ");
        processedArgument = processedArgument.toUpperCase();

        String[] arguments = processedArgument.split(" ");

        if (!areValidSortArguments(arguments)) {
            return new IncorrectCommand(String.format(SortCommand.MESSAGE_SORT_CONSTRAINTS, SortCommand.MESSAGE_USAGE));
        }
        return new SortCommand(stringArrayToSortTypeList(arguments));
    }

    /**
     * Returns true if a given string array has a valid sort arguments
     */
    public static boolean areValidSortArguments(String[] arguments) {
        for (String argument : arguments) {
            if (!checkIfValidSortType(argument)) {
                return false;
            }
        }
        return true;
    }

    private static boolean checkIfValidSortType(String argument) {
        return argument.equals(SortType.PRIORITY.toString()) ||
                argument.equals(SortType.ALPHA.toString()) ||
                argument.equals(SortType.TIME.toString());
    }

    private static List<SortType> stringArrayToSortTypeList(String[] arguments) {
        List<SortType> list = new ArrayList<SortType>();
        try {
            for (String argument : arguments) {
                list.add(SortType.valueOf(argument));
            }
        } catch (IllegalArgumentException e) {
            assert false : "Should check that arguments are valid sort type before converting to list";
        }
        return list;
    }
}
```
###### \java\seedu\doist\model\AliasListMap.java
``` java
    /**
     * @return a set of strings which are the default command words
     */
    public Set<String> getDefaultCommandWordSet() {
        return getDefaultAliasListMapping().keySet();
    }

    @Override
    public Map<String, ArrayList<String>> getAliasListMapping() {
        return Collections.unmodifiableMap(commandAliases);
    }

    /**
     * Returns an unmodifiable list of the alias list of the specified default command word
     */
    public List<String> getAliasList(String defaultCommandWord) {
        return Collections.unmodifiableList(commandAliases.get(defaultCommandWord));
    }

    /**
     * Adds an alias to the alias list for that default command word
     * Also removes any occurrence of that alias in the alias list of other default command words
     */
    public void setAlias(String alias, String commandWord) {
        assert(commandAliases.get(commandWord) != null);
        if (commandAliases == null) {
            setDefaultAliasListMapping();
        }
        for (String word : commandAliases.keySet()) {
            commandAliases.get(word).remove(alias);
        }
        ArrayList<String> aliases = commandAliases.get(commandWord);
        aliases.add(alias);
        commandAliases.replace(commandWord, aliases);
    }

    /**
     * remove the specified alias from the corresponding command word if such alias exists
     * nothing happen it the input string is not an alias
     * @param alias
     */
    public void removeAlias(String alias) {
        for (String word : commandAliases.keySet()) {
            commandAliases.get(word).remove(alias);
        }
    }

    public AliasListMap() {
        setDefaultAliasListMapping();
    }

    public AliasListMap(ReadOnlyAliasListMap src) {
        commandAliases = new HashMap<String, ArrayList<String>>(src.getAliasListMapping());
        if (commandAliases.size() < getDefaultAliasListMapping().size()) {
            setDefaultAliasListMapping();
        }
    }

    // utility methods

    @Override
    public String toString() {
        return commandAliases.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AliasListMap // instanceof handles nulls
                && this.getAliasListMapping().equals((((AliasListMap) other).getAliasListMapping())));
    }

    @Override
    public int hashCode() {
        return commandAliases.hashCode();
    }
}
```
###### \java\seedu\doist\model\ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given to-do list and userPrefs.
     */
    public ModelManager(ReadOnlyTodoList todoList, ReadOnlyAliasListMap aliasListMap, UserPrefs userPrefs,
                          Config config, boolean isTest) {
        super();
        assert !CollectionUtil.isAnyNull(todoList, aliasListMap, userPrefs, config);

        logger.fine("Initializing with To-do List: " + todoList + " aliasListMap: " + aliasListMap
                + " and user prefs " + userPrefs + " and config: " + config);

        this.todoList = new TodoList(todoList);
        this.aliasListMap = new AliasListMap(aliasListMap);
        this.config = config;
        filteredTasks = new FilteredList<>(this.todoList.getTaskList());

        //if (!isTest) {
        updateFilteredListToShowDefault();
        sortTasksByDefault();
        //}
        saveCurrentToHistory();
    }

    public ModelManager() {
        this(new TodoList(), new AliasListMap(), new UserPrefs(), new Config(), false);
    }

    public ModelManager(ReadOnlyTodoList todoList, ReadOnlyAliasListMap aliasListMap, UserPrefs userPrefs,
                          Config config) {
        this(todoList, aliasListMap, userPrefs, config, false);
    }



    //=========== AliasListMap =============================================================
    /** Raises an event to indicate the alias list model has changed */

    @Override
    public ReadOnlyAliasListMap getAliasListMap() {
        return aliasListMap;
    }

    @Override
    public void setAlias(String alias, String commandWord) {
        aliasListMap.setAlias(alias, commandWord);
        indicateAliasListMapChanged();
    }

    @Override
    public void removeAlias(String alias) {
        aliasListMap.removeAlias(alias);
        indicateAliasListMapChanged();
    }

    @Override
    public List<String> getAliasList(String defaultCommandWord) {
        return aliasListMap.getAliasList(defaultCommandWord);
    }

    @Override
    public List<String> getValidCommandList(String defaultCommandWord) {
        List<String> list = new ArrayList<String>(aliasListMap.getAliasList(defaultCommandWord));
        list.add(defaultCommandWord);
        return list;
    }

    @Override
    public Set<String> getDefaultCommandWordSet() {
        return aliasListMap.getDefaultCommandWordSet();
    }

    @Override
    public void resetToDefaultCommandWords() {
        aliasListMap.setDefaultAliasListMapping();
    }

    private void indicateAliasListMapChanged() {
        raise(new AliasListMapChangedEvent(aliasListMap));
    }

```
###### \java\seedu\doist\model\ModelManager.java
``` java
    @Override
    public int finishTask(ReadOnlyTask target) throws TaskNotFoundException,
        TaskAlreadyFinishedException {
        assert target != null;
        try {
            todoList.changeTaskFinishStatus(target, true);
        } catch (TaskAlreadyUnfinishedException e) {
            assert false : "finishTask should not try to unfinish tasks!";
        }
        updateFilteredListToShowDefault();
        sortTasksByDefault();
        indicateTodoListChanged();
        return todoList.getTaskIndex(target);
    }

    @Override
    public int unfinishTask(ReadOnlyTask target) throws TaskNotFoundException,
        TaskAlreadyUnfinishedException {
        try {
            todoList.changeTaskFinishStatus(target, false);
        } catch (TaskAlreadyFinishedException e) {
            assert false : "unfinishTask should not try to finish tasks!";
        }
        updateFilteredListToShowDefault();
        sortTasksByDefault();
        indicateTodoListChanged();
        return todoList.getTaskIndex(target);
    }

    @Override
    public synchronized int addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        todoList.addTask(task);
        updateFilteredListToShowDefault();
        sortTasksByDefault();
        indicateTodoListChanged();
        return todoList.getTaskIndex(task);
    }

    @Override
    public int updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;

        int todoListIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        todoList.updateTask(todoListIndex, editedTask);
        updateFilteredListToShowDefault();
        sortTasksByDefault();
        indicateTodoListChanged();
        return todoList.getTaskIndex(editedTask);
    }

    @Override
    public void sortTasksByDefault() {
        sortTasks(getDefaultSorting());
    }

    @Override
    public List<SortType> getDefaultSorting() {
        List<SortType> sortTypes = new ArrayList<SortType>();
        sortTypes.add(SortType.TIME);
        sortTypes.add(SortType.PRIORITY);
        sortTypes.add(SortType.ALPHA);
        return sortTypes;
    }

    @Override
    public void sortTasks(List<SortType> sortTypes) {
        todoList.sortTasks(parseSortTypesToComparator(sortTypes));
    }

    @Override
    public void sortTasks(Comparator<ReadOnlyTask> comparator) {
        todoList.sortTasks(comparator);
    }

    @Override
    public ReadOnlyTaskCombinedComparator parseSortTypesToComparator(List<SortType> sortTypes) {
        List<Comparator<ReadOnlyTask>> comparatorList = new ArrayList<Comparator<ReadOnlyTask>>();
        // Finished tasks are always put at the bottom
        comparatorList.add(new ReadOnlyTaskFinishedStatusComparator());
        for (SortType type : sortTypes) {
            if (type.equals(SortType.PRIORITY)) {
                comparatorList.add(new ReadOnlyTaskPriorityComparator());
            } else if (type.equals(SortType.TIME)) {
                comparatorList.add(new ReadOnlyTaskTimingComparator());
            } else if (type.equals(SortType.ALPHA)) {
                comparatorList.add(new ReadOnlyTaskAlphabetComparator());
            }
        }
        return new ReadOnlyTaskCombinedComparator(comparatorList);
    }

```
###### \java\seedu\doist\model\ModelManager.java
``` java
  //========== change absolute storage path =================================================
    @Override
    public void changeConfigAbsolutePath(Path path) {
        config.setAbsoluteStoragePath(path.toString());
        try {
            ConfigUtil.saveConfig(config, ConfigUtil.getConfigPath());
            indicateAbsoluteStoragePathChanged();
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
    }

    /** Raises an event to indicate the absolute storage path has changed */
    private void indicateAbsoluteStoragePathChanged() {
        raise(new AbsoluteStoragePathChangedEvent(config.getAbsoluteTodoListFilePath(),
                config.getAbsoluteAliasListMapFilePath(), config.getAbsoluteUserPrefsFilePath()));
    }
}
```
###### \java\seedu\doist\model\ReadOnlyAliasListMap.java
``` java
/**
 * Unmodifiable map of an alias list mapping
 */
public interface ReadOnlyAliasListMap {

    /**
     * Returns an unmodifiable map of an alias list mapping.
     */
    Map<String, ArrayList<String>> getAliasListMapping();

}
```
###### \java\seedu\doist\model\task\FinishedStatus.java
``` java
/**
 * Represents the finished status of a task in the to-do list
 * Default value is "not finished".
 * Will only be "finished" if user "finish" a task with the finish command
 */
public class FinishedStatus {

    private boolean isFinished;

    public FinishedStatus() {
        this(false);
    }

    public FinishedStatus(boolean status) {
        this.isFinished = status;
    }

    public boolean getIsFinished() {
        return this.isFinished;
    }

    public void setIsFinished(boolean isFinished) {
        this.isFinished = isFinished;
    }

    @Override
    public String toString() {
        return Boolean.toString(isFinished);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof FinishedStatus // instanceof handles nulls
                && this.isFinished == (((FinishedStatus) other).getIsFinished())); // state check
    }

    @Override
    public int hashCode() {
        return Boolean.hashCode(isFinished);
    }

}
```
###### \java\seedu\doist\model\task\Priority.java
``` java
/**
 * Represents a task's priority in the to-do list
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 * Default value is NORMAL if not set by user.
 */
public class Priority {

    public static final String EXAMPLE = "HIGH";
    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should be 'NORMAL', "
            + "'IMPORTANT' or 'VERY IMPORTANT'";
    public static final PriorityLevel DEFAULT_PRIORITY = PriorityLevel.NORMAL;

    public enum PriorityLevel {
        NORMAL("Normal"), IMPORTANT("Important"), VERY_IMPORTANT("Very Important");

        private String strValue;
        PriorityLevel(String value) {
            this.strValue = value;
        }

        @Override
        public String toString() {
            return this.strValue;
        }
    }
    private final PriorityLevel priority;

    /**
     * If no parameters are given, it is set to default priority
     */
    public Priority() {
        this.priority = DEFAULT_PRIORITY;
    }

    /**
     * Validates given string priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        final String processedPriority = processPriorityString(priority);
        if (!isValidPriority(processedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
        this.priority = PriorityLevel.valueOf(processedPriority);
    }

    public PriorityLevel getPriorityLevel() {
        return priority;
    }

    /**
     * Returns true if a given string is a valid priority
     */
    public static boolean isValidPriority(String priority) {
        return priority.equals(PriorityLevel.VERY_IMPORTANT.name())
                || priority.equals(PriorityLevel.IMPORTANT.name())
                || priority.equals(PriorityLevel.NORMAL.name());
    }

    /**
     * Process string to process all whitespace, spaces and new line and
     * change all characters to upper case so that it will be a
     * valid priority string
     * @returns string of the processed priority string
     */
    public static String processPriorityString(String priority) {
        // remove all trailing spaces, new line characters etc
        String processedPriority = priority.trim();

        // remove all leading spaces, new line characters etc
        processedPriority = processedPriority.replaceAll("^\\s+", "");

        // replace in-between spaces, new line characters etc with _
        processedPriority = processedPriority.replaceAll("\\s+", "_");
        processedPriority = processedPriority.toUpperCase();
        return processedPriority;
    }

    @Override
    public String toString() {
        return priority.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                && this.priority.equals((((Priority) other).priority))); // state check
    }

    @Override
    public int hashCode() {
        return priority.toString().hashCode();
    }

}
```
###### \java\seedu\doist\model\task\ReadOnlyTask.java
``` java
    /**
     * Compare the priority of two tasks
     * @return: -1 if task2 has a lower priority than task1
     */
    public class ReadOnlyTaskPriorityComparator implements Comparator<ReadOnlyTask> {
        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            // Highest priority to lowest priority
            PriorityLevel task1Priority = task1.getPriority().getPriorityLevel();
            PriorityLevel task2Priority = task2.getPriority().getPriorityLevel();
            return task2Priority.compareTo(task1Priority);
        }
    }

    /**
     * Compare the timing of two tasks
     * @return: -1 if task1 is earlier than task2
     */
    public class ReadOnlyTaskTimingComparator implements Comparator<ReadOnlyTask> {
        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            // Earliest to latest timing
            Date date1 = task1.getDates().getStartDate();
            Date date2 = task2.getDates().getStartDate();
            // Floating tasks are put behind
            if (date1 == null && date2 == null) {
                return 0;
            } else if (date1 == null) {
                return 1;
            } else if (date2 == null) {
                return -1;
            }
            return date1.compareTo(date2);
        }
    }

    /**
     * Compare the tasks by alphabetical order of their description
     * @return: -1 if task1 is less than task2 (alphabetical order)
     */
    public class ReadOnlyTaskAlphabetComparator implements Comparator<ReadOnlyTask> {
        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            // A to Z
            String desc1 = task1.getDescription().desc;
            String desc2 = task2.getDescription().desc;
            return desc1.compareTo(desc2);
        }
    }

    /**
     * Compare the finished status of two tasks
     * @return: -1 if task1 is not finished but task2 is finished
     */
    public class ReadOnlyTaskFinishedStatusComparator implements Comparator<ReadOnlyTask> {
        @Override
        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            FinishedStatus status1 = task1.getFinishedStatus();
            FinishedStatus status2 = task2.getFinishedStatus();
            // finished tasks are put behind
            if (status1.getIsFinished() == status2.getIsFinished()) {
                return 0;
            } else if (!status1.getIsFinished() && status2.getIsFinished()) {
                return -1;
            } else {
                return 1;
            }
        }
    }

```
###### \java\seedu\doist\model\task\UniqueTaskList.java
``` java
    /**
     * Sorts the internal list with comparator
     */
    public void sort(Comparator<ReadOnlyTask> comparator) {
        assert comparator != null;
        internalList.sort(comparator);
    }

```
###### \java\seedu\doist\model\task\UniqueTaskList.java
``` java
    /**
     * Changes the finish status of the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws TaskAlreadyFinishedException if task is already finished but trying to finish it
     * @throws TaskAlreadyUnfinishedException if task is already not finished but trying to unfinish it
     * @returns true if finish status of task is successfully changed
     */
    public boolean changeFinishStatus(ReadOnlyTask toChangeFinish, boolean isToFinish) throws TaskNotFoundException,
            TaskAlreadyFinishedException, TaskAlreadyUnfinishedException {
        assert toChangeFinish != null;

        // Find task in internal list
        final int taskIndex = internalList.indexOf(toChangeFinish);
        boolean taskExists = taskIndex < 0 ? false : true;

        if (!taskExists) {
            throw new TaskNotFoundException();
        } else {
            Task taskToUpdate = internalList.get(taskIndex);
            if (isToFinish) {
                finishTask(taskToUpdate);
            } else {
                unfinishTask(taskToUpdate);
            }
            // Update the observable list so that UI can be updated too
            internalList.set(taskIndex, taskToUpdate);
        }
        return taskExists;
    }

    private void finishTask(Task toFinish) throws TaskAlreadyFinishedException {
        if (toFinish.getFinishedStatus().getIsFinished()) {
            logger.info("Attemping to finish task already finished, task details:\n" + toFinish.getAsText());
            throw new TaskAlreadyFinishedException();
        } else {
            toFinish.setFinishedStatus(new FinishedStatus(true));
        }
    }

    private void unfinishTask(Task toUnfinish) throws TaskAlreadyUnfinishedException {
        if (!toUnfinish.getFinishedStatus().getIsFinished()) {
            logger.info("Attemping to unfinish task that is already not finished, task details:\n"
                    + toUnfinish.getAsText());
            throw new TaskAlreadyUnfinishedException();
        } else {
            toUnfinish.setFinishedStatus(new FinishedStatus(false));
        }
    }

```
###### \java\seedu\doist\model\task\UniqueTaskList.java
``` java
    /**
     * Signals that a task is already finished and you are trying to finish it again
     */
    public static class TaskAlreadyFinishedException extends Exception {}

    /**
     * Signals that a task is already not finished and you are trying to unfinish it
     */
    public static class TaskAlreadyUnfinishedException extends Exception {}

}
```
###### \java\seedu\doist\model\TodoList.java
``` java
    public void sortTasks(Comparator<ReadOnlyTask> comparator) {
        this.tasks.sort(comparator);
    }

```
###### \java\seedu\doist\model\TodoList.java
``` java
    /**
     * Changes finish status of a task
     *  @param readOnlyTask task to have its finish status to be changed
     *  @param isToFinish true if task is to be finished, else task will be unfinished
     */
    public boolean changeTaskFinishStatus(ReadOnlyTask readOnlyTask, boolean isToFinish)
            throws TaskNotFoundException, TaskAlreadyFinishedException, TaskAlreadyUnfinishedException {
        assert readOnlyTask != null;

        Task taskToFinish = new Task(readOnlyTask);
        return tasks.changeFinishStatus(taskToFinish, isToFinish);
    }

    /**
     * Returns the index of a task in the internal list, or -1 if no such task
     */
    public int getTaskIndex(ReadOnlyTask readOnlyTask) {
        return tasks.getTaskIndex(readOnlyTask);
    }

```
###### \java\seedu\doist\storage\JsonUserPrefsStorage.java
``` java
    @Override
    public void setUserPrefsFilePath(String path) {
        this.filePath = path;
    }

    @Override
    public String getUserPrefsFilePath() {
        return filePath;
    }
}
```
###### \java\seedu\doist\storage\Storage.java
``` java
    @Override
    String getAliasListMapFilePath();

    @Override
    Optional<ReadOnlyAliasListMap> readAliasListMap() throws DataConversionException, IOException;

    @Override
    void saveAliasListMap(ReadOnlyAliasListMap aliasListMap) throws IOException;

    /**
     * Saves the current version of the Aliaslist Map to the hard disk.
     *   Creates the data file if it is missing.
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleAliasListMapChangedEvent(AliasListMapChangedEvent almce);

    /**
     * Edits the storage path for todolistStorage, userPrefsStorage, aliasMapStorage
     */
    void handleAbsoluteStoragePathChangedEvent(AbsoluteStoragePathChangedEvent aspce);
}
```
###### \java\seedu\doist\storage\StorageManager.java
``` java
    @Override
    public void setUserPrefsFilePath(String path) {
        userPrefsStorage.setUserPrefsFilePath(path);
    }

    @Override
    public String getUserPrefsFilePath() {
        return userPrefsStorage.getUserPrefsFilePath();
    }

```
###### \java\seedu\doist\storage\StorageManager.java
``` java
    @Override
    public void setTodoListFilePath(String path) {
        todoListStorage.setTodoListFilePath(path);
    }

    // ================ ArrayListMap methods ==============================

    @Override
    public String getAliasListMapFilePath() {
        return aliasListMapStorage.getAliasListMapFilePath();
    }

    @Override
    public Optional<ReadOnlyAliasListMap> readAliasListMap() throws DataConversionException, IOException {
        return readAliasListMap(aliasListMapStorage.getAliasListMapFilePath());
    }

    @Override
    public Optional<ReadOnlyAliasListMap> readAliasListMap(String filePath) throws DataConversionException,
            IOException {
        logger.fine("Attempting to read data from aliaslistmap file: " + filePath);
        return aliasListMapStorage.readAliasListMap(filePath);
    }

    @Override
    public void saveAliasListMap(ReadOnlyAliasListMap aliasListMap) throws IOException {
        saveAliasListMap(aliasListMap, aliasListMapStorage.getAliasListMapFilePath());
    }

    @Override
    public void saveAliasListMap(ReadOnlyAliasListMap aliasListMap, String filePath) throws IOException {
        logger.fine("Attempting to write to aliaslistmap data file: " + filePath);
        aliasListMapStorage.saveAliasListMap(aliasListMap, filePath);
    }

    @Override
    public void setAliasListMapFilePath(String path) {
        aliasListMapStorage.setAliasListMapFilePath(path);
    }

```
###### \java\seedu\doist\storage\StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleAliasListMapChangedEvent(AliasListMapChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data aliaslistmap changed, saving to file"));
        try {
            saveAliasListMap(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    private void moveFileToNewLocation(String oldPath, String newPath) {
        try {
            File oldFile = new File(oldPath);
            if (oldFile.exists() && !oldFile.isDirectory()) {
                File newFile = new File(newPath);
                // Ensure that the new directory exists before moving if not there will be an I/O exception
                newFile.getParentFile().mkdirs();
                Files.move(oldFile.toPath(), newFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
            }
        } catch (IOException e) {
            logger.info("Tried to move any existing files but failed" + StringUtil.getDetails(e));
        }
    }
    @Override
    @Subscribe
    public void handleAbsoluteStoragePathChangedEvent(AbsoluteStoragePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Absolute storage path changed,"
                + "changing for all storages"));
        // Move to the new locations
        moveFileToNewLocation(aliasListMapStorage.getAliasListMapFilePath(), event.aliasListMapPath);
        moveFileToNewLocation(todoListStorage.getTodoListFilePath(), event.todoListPath);
        moveFileToNewLocation(userPrefsStorage.getUserPrefsFilePath(), event.userPrefsPath);
        // Change the paths
        todoListStorage.setTodoListFilePath(event.todoListPath);
        userPrefsStorage.setUserPrefsFilePath(event.userPrefsPath);
        aliasListMapStorage.setAliasListMapFilePath(event.aliasListMapPath);
    }
}
```
###### \java\seedu\doist\storage\util\XMLHashMapAdapter.java
``` java
/**
 * A class to serve as an XML adapter to convert between Java HashMap to
 * XML Serializable Key Values
 * @see XMLSerializableKeysValues
 */
public class XMLHashMapAdapter extends XmlAdapter<XMLSerializableKeysValues,
                                                            Map<String, List<String>>> {

    /**
     * Converts from XML to Map (HashMap)
     */
    @Override
    public Map<String, List<String>> unmarshal(XMLSerializableKeysValues in) throws Exception {
        HashMap<String, List<String>> hashMap = new HashMap<>();
        for (XMLSerializableKeyValueElement entry : in.entries()) {
            hashMap.put(entry.key(), entry.value());
        }
        return hashMap;
    }

    /**
     * Converts from Map (HashMap) to XML
     */
    @Override
    public XMLSerializableKeysValues marshal(Map<String, List<String>> map) throws Exception {
        XMLSerializableKeysValues props = new XMLSerializableKeysValues();
        for (Map.Entry<String, List<String>> entry : map.entrySet()) {
            props.addElement(new XMLSerializableKeyValueElement(entry.getKey(), entry.getValue()));
        }
        return props;
    }

}
```
###### \java\seedu\doist\storage\util\XMLSerializableKeysValues.java
``` java
/**
 * A class to contain a list of XML Serializable Key Value Element
 * @see XMLSerializableKeyValueElement
 */
public class XMLSerializableKeysValues {

    @XmlElement(name = "elements")
    private List<XMLSerializableKeyValueElement> entries = new ArrayList<>();

    List<XMLSerializableKeyValueElement> entries() {
        return Collections.unmodifiableList(entries);
    }

    void addElement(XMLSerializableKeyValueElement element) {
        entries.add(element);
    }
}
```
###### \java\seedu\doist\storage\util\XMLSerializableKeyValueElement.java
``` java
/**
 * An Immutable class with key and value that is serializable to XML format
 */
public class XMLSerializableKeyValueElement {

    @XmlElement(name = "key")
    private String key;

    @XmlElement(name = "value")
    private List<String> value;

    XMLSerializableKeyValueElement() {
    }

    XMLSerializableKeyValueElement(String name, List<String> value) {
        this.key = name;
        this.value = value;
    }

    public List<String> value() {
        return value;
    }

    public String key() {
        return key;
    }
}
```
###### \java\seedu\doist\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    private static final String NULL_STRING = "null";

    @XmlElement(required = true)
    private String desc;

    @XmlElement(required = true)
    private String priority;

    @XmlElement(required = true)
    private String finishedStatus;

    @XmlElement(required = true)
    private String startDate;

    @XmlElement(required = true)
    private String endDate;

    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        desc = source.getDescription().desc;
        priority = source.getPriority().getPriorityLevel().toString();
        finishedStatus = Boolean.toString(source.getFinishedStatus().getIsFinished());
        startDate = getDateString(source.getDates().getStartDate());
        endDate = getDateString(source.getDates().getEndDate());
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    private String getDateString(Date date) {
        if (date != null) {
            return date.toString();
        } else {
            return NULL_STRING;
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        // instead of throwing illegal value exception,
        // can consider just removing the invalid data
        final List<Tag> personTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            personTags.add(tag.toModelType());
        }
        final Description name = new Description(this.desc);
        final Priority priority = new Priority(this.priority);
        final FinishedStatus finishedStatus = new FinishedStatus(Boolean.parseBoolean(this.finishedStatus));
        final Date startDate = getDate(this.startDate);
        final Date endDate = getDate(this.endDate);
        final UniqueTagList tags = new UniqueTagList(personTags);

        return new Task(name, priority, finishedStatus, new TaskDate(startDate, endDate), tags);
    }

    private Date getDate(String dateString) {
        if (dateString.equals(NULL_STRING)) {
            return null;
        } else {
            return TaskDate.parseDate(dateString);
        }
    }
}
```
###### \java\seedu\doist\storage\XmlSerializableAliasListMap.java
``` java
/**
 * An Immutable AliasListMap that is serializable to XML format
 */
@XmlRootElement(name = "aliaslistMap")
@XmlAccessorType(XmlAccessType.FIELD)
public class XmlSerializableAliasListMap implements ReadOnlyAliasListMap {

    @XmlElement(name = "aliasListMap")
    @XmlJavaTypeAdapter(XMLHashMapAdapter.class)
    Map<String, List<String>> aliasListMap;

    /**
     * Creates an empty XmlSerializableAliasListMap.
     * This empty constructor is required for marshalling to XML format.
     */
    public XmlSerializableAliasListMap() {
        aliasListMap = new HashMap<String, List<String>>();
    }

    /**
     * Conversion from model to storage
     */
    public XmlSerializableAliasListMap(ReadOnlyAliasListMap src) {
        this();
        Map<String, ArrayList<String>> map = src.getAliasListMapping();
        for (Map.Entry<String, ArrayList<String>> entry : map.entrySet()) {
            List<String> list = entry.getValue();
            aliasListMap.put(entry.getKey(), list);
        }
    }

    /**
     * Conversion from storage to model
     */
    @Override
    public Map<String, ArrayList<String>> getAliasListMapping() {
        Map<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();
        for (Map.Entry<String, List<String>> entry : aliasListMap.entrySet()) {
            ArrayList<String> list = null;
            if (entry.getValue() != null) {
                list = new ArrayList<String>(entry.getValue());
            } else {
                list = new ArrayList<String>();
            }
            map.put(entry.getKey(), list);
        }
        return map;
    }
}
```
###### \java\seedu\doist\storage\XmlTodoListStorage.java
``` java
    @Override
    public void setTodoListFilePath(String path) {
        this.filePath = path;
    }

}
```
###### \java\seedu\doist\ui\CommandBox.java
``` java
    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
        // Only add success style if don't already have
        if (!commandTextField.getStyleClass().contains(SUCCESS_STYLE_CLASS)) {
            commandTextField.getStyleClass().add(SUCCESS_STYLE_CLASS);
        }
    }

    /**
     * Sets the command box style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        commandTextField.getStyleClass().remove(SUCCESS_STYLE_CLASS);
        // Only add error style if don't already have
        if (!commandTextField.getStyleClass().contains(ERROR_STYLE_CLASS)) {
            commandTextField.getStyleClass().add(ERROR_STYLE_CLASS);
        }
    }
}
```
###### \java\seedu\doist\ui\MainWindow.java
``` java
    @FXML
    private void handleDarkTheme() {
        changeToTheme(darkThemeUrl);
    }

    @FXML
    private void handleLightTheme() {
        changeToTheme(lightThemeUrl);
    }

    private void changeToTheme(String themeUrl) {
        Scene scene = primaryStage.getScene();
        // Remove all existing stylesheets
        scene.getStylesheets().removeAll(themeUrls);
        // Add the new stylesheet
        if (!scene.getStylesheets().contains(themeUrl)) {
            scene.getStylesheets().add(themeUrl);
        }
    }

```
###### \java\seedu\doist\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleStoragePathChangedEvent(AbsoluteStoragePathChangedEvent aspce) {
        logger.info(LogsCenter.getEventHandlingLogMessage(aspce, "Setting storage path display to "
                + aspce.todoListPath));
        setSaveLocation(aspce.todoListPath);
    }
}
```
###### \java\seedu\doist\ui\TaskCard.java
``` java
public class TaskCard extends UiPart<Region> {

    private static final String FXML = "TaskListCard.fxml";
    private static final String START_TIME_TEXT = "Start: ";
    private static final String END_TIME_TEXT = "End: ";
    private static final String BY_TIME_TEXT = "By: ";
    public static final String NORMAL_STYLE_CLASS = "normal";
    public static final String OVERDUE_STYLE_CLASS = "overdue";
    public static final String FINISHED_STYLE_CLASS = "finished";

    @FXML
    private HBox cardPane;
    @FXML
    private GridPane grid;
    @FXML
    private VBox sideBox;
    @FXML
    private VBox taskBox;
    @FXML
    CheckBox checkbox;
    @FXML
    private Label desc;
    @FXML
    private Label id;
    @FXML
    private Label priority;
    @FXML
    private Label startTime;
    @FXML
    private Label endTime;
    @FXML
    private FlowPane tags;

    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        setStyleToNormal();
        desc.setText(task.getDescription().desc);
        id.setText(displayedIndex + ". ");
        priority.setText(task.getPriority().toString());

        // Times
        if (task.getDates().isDeadline()) {
            startTime.setText(BY_TIME_TEXT + prettyDate(task.getDates().getStartDate()));
            endTime.setText("");
        } else if (task.getDates().isEvent()) {
            startTime.setText(START_TIME_TEXT + prettyDate(task.getDates().getStartDate()));
            endTime.setText(END_TIME_TEXT + prettyDate(task.getDates().getEndDate()));
        } else {
            // floating task
            startTime.setText("");
            endTime.setText("");
        }
        if (task.getDates().isPast()) {
            setStyleToOverdue();
        }

        // Finished
        checkbox.setDisable(true);
        checkbox.setStyle("-fx-opacity: 1");
        if (task.getFinishedStatus().getIsFinished()) {
            checkbox.setSelected(true);
            setStyleToFinished();
        } else {
            checkbox.setSelected(false);
        }

        // Tags
        initTags(task);
    }

    private void initTags(ReadOnlyTask task) {
        task.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }

    /**
     * Sets the card pane style to the style of a normal task
     */
    private void setStyleToNormal() {
        cardPane.getStyleClass().remove(OVERDUE_STYLE_CLASS);
        cardPane.getStyleClass().remove(FINISHED_STYLE_CLASS);
        // Only add style if don't already have
        if (!cardPane.getStyleClass().contains(NORMAL_STYLE_CLASS)) {
            cardPane.getStyleClass().add(NORMAL_STYLE_CLASS);
        }
    }

    /**
     * Sets the card pane style to the style of an overdue task
     */
    private void setStyleToOverdue() {
        cardPane.getStyleClass().remove(NORMAL_STYLE_CLASS);
        cardPane.getStyleClass().remove(FINISHED_STYLE_CLASS);
        // Only add style if don't already have
        if (!cardPane.getStyleClass().contains(OVERDUE_STYLE_CLASS)) {
            cardPane.getStyleClass().add(OVERDUE_STYLE_CLASS);
        }
    }

    /**
     * Sets the card pane style to the style of a normal task
     */
    private void setStyleToFinished() {
        cardPane.getStyleClass().remove(OVERDUE_STYLE_CLASS);
        cardPane.getStyleClass().remove(NORMAL_STYLE_CLASS);
        // Only add style if don't already have
        if (!cardPane.getStyleClass().contains(FINISHED_STYLE_CLASS)) {
            cardPane.getStyleClass().add(FINISHED_STYLE_CLASS);
        }
    }

```
###### \resources\view\DarkTheme.css
``` css
@import url("CommandBoxCss.css");
@import url("Extensions.css");

.background {
    -fx-background-color: #000000;
}

.check-box>.box {
  -fx-background-insets: 0;
  -fx-background-radius: 0;
  -fx-background-color: #777777;
}

.check-box:selected>.box>.mark {
  -fx-background-color: white;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.list-view {
    -fx-selection-bar:#777777;
    -fx-selection-bar-non-focused: #777777;
    -fx-background-insets: 0;
    -fx-padding: -2px;
}

.list-view .list-cell:even {
    -fx-control-inner-background: #424242;
}

.list-view .list-cell:odd {
    -fx-control-inner-background: #303030;
}

.list-cell {
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
    -fx-border-color: transparent;
}

.list-cell .label {
    -fx-text-fill: white;
}

.cell_big_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_small_label {
    -fx-font-size: 11px;
    -fx-text-fill: #010504;
}

.anchor-pane {
     -fx-background-color:#303030;
     -fx-text-fill: #010504;
}

.anchor-pane-with-border {
     -fx-background-color: #303030;
     -fx-border-color: #303030;
     -fx-border-top-width: 1px;
}

.status-bar {
    -fx-background-color: #000000;
}

.result-display {
    -fx-background-color: #000000;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: white;
}

.status-bar-with-border {
    -fx-background-color: #303030;
    -fx-border-color: transparent;
    -fx-border-width: 0px;
}

.status-bar-with-border .label {
    -fx-text-fill: white;
}

.grid-pane {
    -fx-background-color: transparent;
    -fx-border-color: #303030;
    -fx-border-width: 1px;
}

.grid-pane .anchor-pane {
    -fx-background-color: #303030;
}

.context-menu {
    -fx-background-color: #303030;
}

.context-menu .label {
    -fx-text-fill: white;
}

.menu-bar {
    -fx-background-color:#303030;
}

.menu-item:focused {
    -fx-background-color:#212121;
}
.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: black;
}

.menu:showing {
    -fx-background-color: #303030;
}
.menu:hover {
    -fx-background-color: #303030;
}
/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: derive(#1d1d1d, 25%);
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-font-style: italic;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .track-background {
    -fx-background-color: #212121;
}
.scroll-bar .thumb {
    -fx-background-color: #555555;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-width: 0 0 0 4;
}

/* for normal tasks in cardPane */
.normal {
    -fx-border-color: #76d7ea;
}

/* for overdue tasks in cardPane */
.overdue {
    -fx-border-color: #fc80a5;
}

/* for finished tasks in cardPane */
.finished {
    -fx-border-color: #99ff99;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#sideBox {
    -fx-border-color: transparent;
}

.text-area {
    -fx-background-insets: 0;
    -fx-text-fill: white;
    -fx-padding: -2px;
}

.text-area .content {
    -fx-background-color: #212121;
    -fx-border-color: #212121;
}

.text-area:focused .content {
    -fx-background-color: #212121;
}

.text-area:focused {
    -fx-highlight-fill: white;
}

#taskBox {
    -fx-border-color: #212121;
    -fx-border-width: 0 0 0 0;
}

#filterField, #personListPanel, #personWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

#tags {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #888888;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}
```
###### \resources\view\Extensions.css
``` css
.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}

.tooltip-text {
    -fx-text-fill: white;
}

.error {
    -fx-background-color: #ffb3b3;
}

.white {
    -fx-background-color: #a9a9a9 , white , white;
}
```
###### \resources\view\LightTheme.css
``` css
@import url("CommandBoxCss.css");
@import url("Extensions.css");

.background {
    -fx-background-color: #000000;
}

.check-box>.box {
  -fx-background-insets: 0;
  -fx-background-radius: 0;
  -fx-background-color: #DFEFF0;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.list-view {
    -fx-selection-bar:#A0C6DD;
    -fx-selection-bar-non-focused: #A0C6DD;
    -fx-background-insets: 0;
}

.list-view .list-cell:even {
    -fx-control-inner-background: #F5FAFA;
    -fx-text-fill: black;
}

.list-view .list-cell:odd {
    -fx-control-inner-background: transparent;
    -fx-text-fill: black;
}

.list-cell {
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
    -fx-border-color: transparent;
}

.list-cell .label {
    -fx-text-fill: #010504;
}

.cell_big_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_small_label {
    -fx-font-size: 11px;
    -fx-text-fill: #010504;
}

.anchor-pane {
     -fx-background-color:#FFFFFF;
     -fx-text-fill: #010504;
}

.anchor-pane-with-border {
     -fx-background-color: #FFFFFF;
     -fx-border-color: #FFFFFF;
     -fx-border-top-width: 1px;
}

.status-bar {
    -fx-background-color: #000000;
}

.result-display {
    -fx-background-color: #000000;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: black;
}

.status-bar-with-border {
    -fx-background-color: #FFFFFF;
    -fx-border-color: transparent;
    -fx-border-width: 0px;
}

.status-bar-with-border .label {
    -fx-text-fill: black;
}

.grid-pane {
    -fx-background-color: transparent;
    -fx-border-color: transparent;
    -fx-border-width: 1px;
}

.grid-pane .anchor-pane {
    -fx-background-color: #FFFFFF;
}

.context-menu {
    -fx-background-color: #FFFFFF;
}

.context-menu .label {
    -fx-text-fill: black;
}

.menu-bar {
    -fx-background-color:#FFFFFF;
}

.menu-item:focused {
    -fx-background-color:#F5FAFA;
}
.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: black;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: black;
}

.menu:showing {
    -fx-background-color: #F5FAFA;
}
.menu:hover {
    -fx-background-color: #F5FAFA;
}
/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: derive(#1d1d1d, 25%);
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-font-style: italic;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .track-background {
    -fx-background-color: #F5FAFA;
}
.scroll-bar .thumb {
    -fx-background-color: #6D929B;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-width: 0 0 0 4;
}

/* for normal tasks in cardPane */
.normal {
    -fx-border-color: #76d7ea;
}

/* for overdue tasks in cardPane */
.overdue {
    -fx-border-color: #fc80a5;
}

/* for finished tasks in cardPane */
.finished {
    -fx-border-color: #99ff99;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#sideBox {
    -fx-border-color: transparent;
}

.text-area {
    -fx-background-insets: 0;
    -fx-background-color: #F5FAFA;
    -fx-text-fill: #005B9A;
}

.text-area .content {
    -fx-background-color: #F5FAFA;
}

.text-area:focused .content {
    -fx-background-color: #F5FAFA;
}

.text-area:focused {
    -fx-highlight-fill: #7ecfff;
}

#taskBox {
    -fx-border-color: #89CFF0;
    -fx-border-width: 0 0 0 0;
}

#filterField, #personListPanel, #personWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

#tags {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #383838;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}
```
###### \resources\view\MainWindow.fxml
``` fxml

<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Theme">
              <items>
                <MenuItem mnemonicParsing="false" onAction="#handleLightTheme" text="LightTheme" />
                  <MenuItem mnemonicParsing="false" onAction="#handleDarkTheme" text="DarkTheme" />
              </items>
            </Menu>
         </menus>
      </MenuBar>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
       <AnchorPane styleClass="anchor-pane" VBox.vgrow="ALWAYS">
          <children>
               <VBox fx:id="personList" maxHeight="Infinity" maxWidth="Infinity" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                   <padding>
                       <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                   </padding>
                  <children>
                     <AnchorPane fx:id="personListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                  </children>
               </VBox>
          </children>
       </AnchorPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
</VBox>
```
###### \resources\view\TaskListCard.fxml
``` fxml
<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane fx:id="grid" HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="ALWAYS" maxWidth="40.0" />
            <ColumnConstraints hgrow="ALWAYS" minWidth="150.0" prefWidth="100.0" />
            </columnConstraints>
            <children>
            <VBox fx:id="sideBox" maxWidth="100.0" prefHeight="100.0" prefWidth="10.0">
               <children>
                  <CheckBox fx:id="checkbox" mnemonicParsing="false">
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </CheckBox>
               </children>
            </VBox>
            <VBox fx:id="taskBox" prefHeight="100.0" GridPane.columnIndex="1">
               <children>
                          <HBox>
                            <children>
                             <Label fx:id="id" styleClass="cell_big_label"></Label>
                                 <Label fx:id="desc" styleClass="cell_big_label" text="\$first" />
                             </children>
                          </HBox>
                        <FlowPane fx:id="tags" alignment="CENTER_LEFT" />
                        <Label fx:id="priority" styleClass="cell_small_label" text="\$priority" />
                        <Label fx:id="startTime" styleClass="cell_small_label" text="\$startTime" />
                        <Label fx:id="endTime" styleClass="cell_small_label" text="\$endTime" />
               </children>
            </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
